import java.util.StringTokenizer;

public class TestInfix2PostfixCalculator {
	
	public static void main(String[] args) {
		
		printResults("(10 + 3 * 4 / 6)");
		printResults("12*3 - 4 + (18/6)");
		printResults("35 - 42* 17 /2 + 10");
		printResults("3 * (4 + 5)");
		printResults("3 * ( 17 - (5+2))/(2+3)");
	}
	
	private static String convertPostFix(String infix) {
		infix = infix.replaceAll("\\s", "");
		
		StackReferenceBased opStack = new StackReferenceBased();
		char curr;
		String output = "";
		int i = 0;
		
		while (i != infix.length()) {
			curr = infix.charAt(i);
			if (precedence(curr) == -1) {
				int j = i + 1;
				String operand = infix.substring(i, j);
				while (j != infix.length() && precedence(infix.charAt(j)) == -1) {
					j++;
					operand = infix.substring(i, j);
				}
				i = j;
				output += " " + operand;
 			} else {
 				i++;
				if (curr == ')') {
					for (Object o = opStack.pop(); o.toString().charAt(0) != '('; o = opStack.pop()) {
						char c = o.toString().charAt(0);
						if (precedence(c) != 0)
							output += " " + c;
					}
				} else {
					while (!opStack.isEmpty() && curr != '(' && precedence(opStack.peek().toString().charAt(0)) >= precedence(curr)) {
						char c = opStack.pop().toString().charAt(0);
						if (precedence(c) != 0)
							output += " " + c;
					}
					opStack.push(curr);
				}
			}
		}
		while (!opStack.isEmpty()) {
			char c = opStack.pop().toString().charAt(0);
			if (precedence(c) != 0)
				output += " " + c;
		}
		return output.trim();
	}
	
	private static int getPostFix(String postfix) {
		// Tokenize the postfix notation expression, since I made sure there are spaces between everything in the other method
		StringTokenizer tokens = new StringTokenizer(postfix);
		
		// Stack for holding operands and operators
		StackReferenceBased stack = new StackReferenceBased();
		
		// Continue running this until there are no more operands or operators
		while (tokens.hasMoreTokens()) {
			String curr = tokens.nextToken();
			
			// if operator is obtained from tokens, pop the stack twice and operate on them, then push the result on the stack
			// otherwise its an operand, so just push it on the stack
			if (precedence(curr.charAt(0)) != -1)
				stack.push(doMath(stack.pop(), stack.pop(), curr.charAt(0)));
			else
				stack.push(curr);
		}
		
		// the final result is at the top of the stack, so just pop it and make it an int
		return Integer.valueOf(stack.pop().toString());
	}
	
	/**
	 * Helper method for determining which operator to use based on the given
	 * char representation of the operator. Operates on the two given operands.
	 * 
	 * @param a one of the operands
	 * @param b the other operand
	 * @param op char representation of the operator to use
	 * @return the result 
	 */
	private static int doMath(Object a, Object b, char op) {
		// the first popped (a) should be the antecedent operand
		// the second popped (b) should be the precedent operand
		// important for subtraction and division
		int x = Integer.valueOf(b.toString());
		int y = Integer.valueOf(a.toString());
		
		// switch case for different operators
		switch (op) {
			case '+':
				return x + y;
			case '-':
				return x - y;
			case '*':
				return x * y;
			case '/':
				return x / y;
		}
		return -1;
	}
	
	/**
	 * Helper method to determine
	 * @param op
	 * @return
	 */
	private static int precedence(char op) {
		if (op == '(' || op == ')')
			return 0;
		if (op == '+' || op == '-')
			return 1;
		if (op == '*' || op == '/')
			return 2;
		return -1;
	}
	
	private static void printResults(String infix) {
		System.out.println("infix: " + infix);
		System.out.println("postfix: " + convertPostFix(infix));
		System.out.println("result: " + getPostFix(convertPostFix(infix)) + "\n");
	}
}
